<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			/*
			函数的声明和调用

			函数的概念：
			把一段相对独立的具有特定功能的代码块封装（写到一个地方），形成一个独立实体，就是函数，起个名字(函数名),在后续开发中可以反复调用。

			函数的作用就是封装一段代码，将来可以重复使用

			声明方式：

			//关键字声明

			function函数名(){

			代码

			}

			//表达式声明

			var f (函数名)= function(){

			代码

			}
			*/

			//函数声明后,里面的代码是不会执行;

			//函数中的代码想要执行，必须调用这个函数〈不管什么情况下，函数不调用就一定不会执行)

			// 调用方法：

			function f1(){

			console.log(2);

			}
			f1()

			//函数的调用    函数 ming()

			// f1();（f1() 出现几次就是调用几次）

			// 案例 1 ：
			function s(){
				var s=0;
				for(var i=0;i<=100;i++){
					s+=i;
				}
				console.log(s);
			}

			s()

			// 形参与实参
			/*

			三、形参和实参
			1、形式参数：是在声明函数时写的；多个形参使用‘隔开；形参的值时不固定，形参仅仅是一个占位
			2、占位：与实参实际传入的值要一一对应
			3、实际参数：实在调用时，实际传入函数中的值；多个值使用，隔开；传入后，在函数中使用形式参数获取具体的值

			*/
		   // 一、范例一：
		  //  function s() {
		  //  var n=0;
		  //  for(var i=0; i <= 60; i++) {
				// n += i;
		  //  }
				// console.log(n);
		  //  }
		  //  s()
		   //function fun(形参1、形参2...){ }变量的名字称为形参
		   //fun(实参1、实参2）

		   // 二、范例二：
		   function s(k){
		   var n = 0 ;
		   for (var i = 0;i <= k; i++) {
				n += i;
		   }
				console.log(n);
		   }
		   s(5);

		   function sum(a,b){
			   console.log(a+b);
		   }
		   sum(2,6);

		// 代码执行完后要给它代用一个返回值，把想要返回的值写在 return 后面
			function f(a,b){
				var c = a-b;
				return c;
			}

			var h=f(5,2);
			console.log(h);

			/*

				此时 h 就是函数的返回值，即 h 就是3。
				若没有返回的话，h 就是 undefined
				即如果函数中没有 return，那么函数调用之后接到的返回值就是 undefined；
				除此之外，如果函数中有 return，但 return 后面没有值，那么函数调用之后接到的返回值还是 undefined，或者函数中 return 之后，不管有什么代码均不执行，return 后函数的调用结束。
			*/

		   /*
		   匿名函数与自调用
		   匿名函数：没有名字的函数
		   匿名函数如何使用：
		   将匿名函数赋值给一个变量，这样就可以通过变量进行调用

		   */

			var fun=function(){
				console.log(1)
			}
			fun();

			// 立即执行函数 自调用匿名函数
			// 关于自执行函数(匿名函数自调用)的作用：防止全局变量污染。
			(function(){
				// alert(123);
			})();

			/*
			函数当作参数
			//函数也是一种数据类型
			function fn() {
			}
			// funtion 数据类型 --> 对象(数组、函数)
			console.log( typeof fn);

			function f1(s) {
			var k = 123+S;
			console.log.(k);
			s();
			}
			var f2 = function(){
			console.log(222);
			}
			// f2 函数会被当做值，传入 f1 函数内
			f1(f2);

			*/
		   function fn(){

		   }
		   console.log(typeof fn); //function

		   function f1(s){
			   var k=123+s;
			   console.log(k);
		   }
		   f1("sss");

		   var f2=function(){
			   console.log(222);
		   }
		   // f2函数会被当做值，传入f1函数内
		   f1(f2);

		   function f1(){
			   var a=10;
			   var f2=function(){
				   alert(2);
			   }
			   return f2;
		   }
		   // 闭包
		   var k=f1();
		   // k();
		   /*
			变量提升及代码执行阶段
			一、全局变量和局部变量
			作用域：变量可以起作用的范围和区域
			1. 全局变量与全局作用域
			在任何地方都可以访问到的变量就是全局变量，全局变量所在的区域就是全局作用域
			2. 局部变量与局部作用域
			只在固定的代码片段内可访问到的变量，最常见的例如函数内部的变量，就是局部变量，局部变量所在区域就是局部作用域（函数作用域）
			3. 注意
			不适用 var 声明的变量是全局变量，不推荐使用。
			变量退出作用域之后会销毁，全局变量关闭网页和浏览器才会销毁。

			变量提升:在代码执行之前变量已经在编译阶段被声明了

			JS 代码的运行分为两个阶段
			1． 解析（编译）阶段：语法检查，变量及函数进行声明
			2． 运行阶段：变量的赋值，代码流程的执行

		   */

		  // 全局作用域和局部作用域的区别
		// var a=1;	//函数外面 是全局作用域
		function f1(){
			// var a=2;	//局部作用域
		}
		// console.log(a);	//a is not defined
		// var a;
		// console.log(a);//函数在外面就是全局作用域

		// var a;  {先进行变量的声明}
		// console.log(a);
		// a=2  {然后进行变量的赋值}
		// 注意：如果一个变量声明了但是没有赋值就会是 undefined

		</script>
	</body>
</html>